# 4. 고급조인기법 - 48번

**기록 ✍️**

#### author : jung yuha

#### **first Registered : 2022-06-25**

#### last modified : **2022-06-25**

## **\[1]** 문제 <a href="#undefined" id="undefined"></a>

아래 SQL을 튜닝하세요.\
\-결과 집합을 모두 출력하는 애플리케이션 환경을 기준으로 튜닝하세요.\
\-필요하다면, 인덱스 재구성 안을 제시하세요.\
\-튜닝 의도대로 정확히 실행되도록 옵티마이저 힌트를 기술하세요.

### \[1] SQL <a href="#1-sql" id="1-sql"></a>

```sql
SQL > SELECT P.상품코드 , MIN(P.상품명) 상품명 , MIN(P.상품가격) 상품가격
, SUM(O.주문수량) 총주문수량 , SUM(O.주문금액) 총주문금액
FROM 상품 P , 주문상품 O
WHERE O.주문일시 >= ADD_MONTHS(SYSDATE,-1)
AND O.할인유형코드 = 'K890'
AND P.상품코드 = O.상품코드
GROUP BY P.상품코드
ORDER BY 총 주문금액 DESC , 상품코드

Execution Plan
------------------------------------------------------------------------------ 
|  0| SELECT STATEMENT Optimizer=ALL_ROWS (cost = 279 card=206 Bytes=1k)
|  1|  SORT (ORDER BY) (cost = 279 card=206 Bytes=11k)
|  2|   HASH (GROUP BY) (cost = 279 card=206 Bytes=11k)
|  3|    NESTED LOOPS (cost = 277 card=206 Bytes=11K) 
|  4|     NESTED LOOPS (cost = 277 card=206 Bytes=11K) 
|  5|     	PARTITION RANGE (ITERATOR) (cost = 70 card=206 Bytes=9K) 
|  6|      		TABLE ACCESS (BY LOCAL INDEX ROWID) OF '주문상품' (TABLE) (...)
|  7|       		INDEX (RANGE SCAN) OF '주문상품_X1' (INDEX) (cost = 34 card=15)
|  7|      	INDEX (UNIQUE SCAN) OF '상품_PK' (INDEX (UNIQUE)) (cost = 0 card=1)
|  8|     TABLE ACCESS (BY INDEX ROWID) OF '상품' (TABLE) (cost = 1 card=1...)
------------------------------------------------------------------------------
```

### \[2] 테이블 구성 및 데이터 <a href="#2" id="2"></a>

* 주문 상품은 월 단위 파티션 테이블 (주문일시 기준)
* 한 달 주문상품 = 100만건
* 주문상품의 보관 기관 = 10년
* 주문상품 총 건수 = 총 1억 2천만 건 (=100만 X 120개월)
* 할인유형코드 조건을 만족하는 데이터 비중 = 20%
* 등록된 상품 = 2만개
* 대부분 상품을 한달에 한 개 이상 주문

### \[3] 인덱스 구성 <a href="#3" id="3"></a>

* 상품\_PK : 상품코드
* 주문상품\_PK : 고객번호 + 상품코드 + 주문일시
* 주문상품\_X1 : 주문일시 + 할인유형코드

## \[2] 풀이

**🍎 부분은 내가 생각했을때 튜닝하면서 봐야할 핵심부분을 체크한 곳이다.**

### 1) 데이터 정리 <a href="#1" id="1"></a>

#### 1.주문 상품 테이블 <a href="#1" id="1"></a>

* 🍎월 단위 파티션🍎 테이블
* 한 달 주문상품 = 100만건
* 주문상품 총 건수 = 총 1억 2천만 건 (=100만 X 120개월)
* 할인유형코드 조건을 만족하는 데이터 비중 = 🍎20%🍎

#### 2.상품 테이블 <a href="#2" id="2"></a>

* 등록된 상품 = 2만개
* 🍎대부분 상품을 한달에 한 개 이상 주문🍎

### 2) 기존 쿼리 분석 <a href="#2" id="2"></a>

**1. 주문상품 해당 월 파티션 액세스**\
**2. 주문상품\_X1 로컬 파티션 인덱스 스캔**

* 한 달 동안 주문된 100만건 : '주문일시' **액세스**
* 할인 유형 코드가 'k890'인 : '할인유형코드' **스캔**
  * 100만건중 **20%** 즉 , 20만건

**3. 2단계의 20만건을 상품 테이블과 NL조인**

* 🍎NL조인이 일어나는 횟수 : 20만건🍎

**4. 3단계의 20만건을 grouping**

* 대부분 상품을 한달에 한 개 이상 주문했으므로 그룹핑하면 약 2만건 추출

**5. 4단계의 2만건 Sort**

### 3) 🍎쿼리 튜닝🍎 <a href="#3" id="3"></a>

#### 1.주문 상품 테이블 액세스 <a href="#1" id="1"></a>

* **100만건의 파티션 테이블에서 20만건을 뽑아내므로 **_**Full Scan**_**을 유도한다.**

#### 2.상품 테이블 액세스 <a href="#2" id="2"></a>

* 등록된 상품 = 2만개이고 2만 개 상품을 고르게 주문하므로 상품 테이블의 약 대개의 데이터가 액세스될 것이다.
  * **따라서 상품 테이블을 Full 스캔할 수 있도록 유도한다.**
  * Full 스캔하면 따라오는 건 뭐다? **해시 조인**인 거시다\~\~!

#### 3.주문상품 - 상품 테이블 조인 방식 <a href="#3" id="3"></a>

* ⭐️ 우선 20만건의 NL조인을 다른 방법의 조인으로 바꿔야한다. ⭐️
  * **주문 상품 테이블 따로 그룹핑을 하여 조인 대상 로우수를 2만건으로 줄인다.**

### 4) 튜닝한 SQL문 <a href="#4-sql" id="4-sql"></a>

```sql
SELECT /*+ LEADING(P) USE_HASH(O) FULL(P)*/
	P.상품코드 , P.상품명 , P.상품가격 , O.총주문수량 , O.총주문금액
FROM ( SELECT /*+ FULL(A) NO_MERGE*/ 상품코드 ,SUM(O.주문수량) 총주문수량 , SUM(O.주문금액) 총주문금액
  FROM 주문상품 A
  WHERE 주문일시 >= ADD_MONTHS(SYSDATE,-1)
  AND 할인유형코드 = 'K890'
  GROUP BY 상품코드 ) O , 상품 P
WHERE O.상품코드 = P.상품코드
ORDER BY 총 주문금액 DESC , 상품코드
```

> **😥 헷갈렸던 부분**
>
> * 🍎push\_pred는 쓰지 않는다!
>   * 왜냐하면 상품(P) 테이블을 먼저 리딩해서 해시맵에 깔아놓고 그 후에 그룹핑한 주문상품 2만건을 하나씩 해시조인 하는 방식으로 풀어냈기 때문이다.
