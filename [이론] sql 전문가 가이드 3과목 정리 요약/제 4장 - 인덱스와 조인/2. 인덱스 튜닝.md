# 2. 인덱스 튜닝

**기록 ✍️**

#### author : jung yuha

#### **first Registered : 2022-04-12**

#### last modified : **2023-04-21**



## \[1] 인덱스 튜닝

### (1) B\*Tree 인덱스를 활용한 인덱스 튜닝 방법

아래 세 경우 모두 정상적인 인덱스 범위 스캔이 불가능할 따름이지 인덱스 사용 자체가 불가능하지는 않다. Index Full Scan은 가능하다.

#### 1. 범위 스캔이 불가능하거나 인덱스 사용이 아예 불가능한 경우

* 인덱스 선두 칼럼을 조건절에서 가공하는 경우 (FBI 인덱스를 정의하지 않는 한)

```sql
select * from 업체 where substr(업체명, 1, 2) = '대한'
```

* 묵시적 형변환 : 인덱스 칼럼을 사용자가 명시적으로 가공하지 않더라도 조건절에서 비교되는 두 값의 데이터 타입이 다르면 내부적으로 형변환
* 가급적 명시적으로 변환함수를 사용하는 것이 좋다.
* 문자형과 숫자형이 만나면 숫자형으로, 문자형과 날짜형이 만나면 날짜형으로 변환하는 등 데이터 타입간 우선순위가 존재한다.
  * 성능을 위해서라면 인덱스 칼럼과 비교되는 반대쪽을 인덱스 칼럼 데이터 타입에 맞춰면 된다.
* 묵시적 형변환은 주로 성능 측면에서 언급되곤 하지만, 올바른 결과집합을 얻기 위해서라도 변환함수를 명시하는 것이 바람직하다.
  * 묵시적 형변환은 쿼리 수행 도중 에러를 발생시키거나 결과집합을 틀리게 만드는 요인이 될 수 있기 때문

```sql
SQL> select * from emp where deptno='20'; -- access("DEPTNO"=20) => 문자형 상수 '20'이 숫자형 20으로 변환됨
-- 묵시적 형변환이 잘못된 경우
 SQL> select * from emp where cdeptno=20; -- filter(TO_NUMBER("CDEPTNO")=20) => 문자형 CDEPTNO 칼럼이 숫자형으로 변환됨
-- 문자형 cdeptno 칼럼이 숫자형으로 변환된 것을 볼 수 있고, emp 테이블을 Full Scan하는 실행계획이 수립되었다.

```

#### 2. 부정형 비교

* 정상적인 인덱스 사용은 어렵다.

```sql
select * from 고객 where 직업 <> '학생' ; 
```

* is not null 조건도 부정형 비교에 해당된다.

```sql
select * from 사원 where 부서코드 is not null ; 
```

* Oracle에서 ‘부서코드’에 단일 칼럼 인덱스가 존재한다면 그 인덱스 전체를 스캔하면서 얻은 레코드는 모두 ‘부서코드 is not null’ 조건을 만족한다.
* Oracle은 단일 칼럼 인덱스에 null 값은 저장하지 않기 때문이다.
* 결합 인덱스일 때는 인덱스 구성 칼럼 중 하나라도 값이 null이 아닌 레코드는 인덱스에 저장한다.
* 인덱스도 구성칼럼이 모두 null인 레코드에서 is null 조건만으로 검색할 때 :: 인덱스만 뒤져선 찾을 수 없다. 즉 , 인덱스 사용이 불가능
* QL Server는 단일, 결합을 가리지 않고 null이 아닌 레코드를 인덱스에서 모두 찾을 수 있다.

**is null 조건에 대한 Index Range Scan이 가능한 경우**

* 다른 인덱스 칼럼에 is null이 아닌 조건식이 하나라도 있는 경우
* 다른 인덱스 칼럼에 not null 제약이 있는 경우
* 물론 인덱스 선두 칼럼이 조건절에 누락되지 않아야 한다.
