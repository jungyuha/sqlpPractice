# 2. SQL 파싱 부하

**기록 ✍️**

#### author : jung yuha

#### **first Registered : 2022-04-12**

#### last modified : **2022-04-12**

## 성능튜닝의 3대 요소

### (1) sql파싱부하해소

### (2) 데이터베이스 call최소화

### (3) I/O효율화

## \[1] SQL 처리과정

* 구조화된 질의언어(SQL, Structured Query Language)를 통해 사용자가 원하는 결과집합만 정의
* 옵티마이저에 의해 생성된 처리절차를 실행계획(Execution Plan)이라고 함
* 실행계획이 실제 실행 가능한 형태는 아니므로 코드(또는 프로시저) 형태로 변환하는 과정을 거치고 나서 SQL 엔진에 의해 수행된다.
  * **SQL 파싱 : 실행계획이 실제 실행 가능한  코드(또는 프로시저) 형태로 변환한다.**
  * **최적화 과정 : 옵티마이저가 가장 빠르고 효율적으로 수행할 최적(최저비용)의 처리경로를 생성하고 선택한다.**

### (1) SQL 파싱(Parsing)

* 사용자가 SQL을 실행하면 제일 먼저 SQL 파서(Parser)가 SQL 문장에 문법적 오류가 없는지를 검사(→Syntax 검사)한다.
  * 문법적으로 오류가 없으면 의미상 오류가 없는지를 검사(→Semantic 검사)한다.
    * 존재하지 않거나 권한이 없는 객체를 사용했는지
    * 존재하지 않는 칼럼을 사용했는지 등
* 이런 검사를 마치면 사용자가 발행한 SQL과 그 실행계획이 라이브러리 캐시에 캐싱됐는지를 확인한다.
* 만약 캐싱돼 있다면, 무거운 최적화 과정을 거치지 않고 곧바로 실행할 수 있다.
* 라이브러리 캐시는 해시구조로 관리된다.
  * SQL마다 해시 값에 따라 여러 해시 버킷으로 나누어 저장된다.
  * SQL을 찾을 때는 SQL 문장을 해시 함수에 입력해서 반환된 해시 값을 이용해 해당 해시버킷을 탐색한다.

#### \[ 파싱의 종류 ]

#### 1. 소프트 파싱(Soft Parsing)

* SQL과 실행계획을 캐시에서 찾아 곧바로 실행단계로 넘어가는 경우이다.

#### 2.  하드 파싱(Hard Parsing)

* SQL과 실행계획을 캐시에서 찾지 못해 최적화 과정을 거치고 나서 실행단계로 넘어가는 경우이다.

### (2) SQL 최적화(Optimization)

#### **옵티마이저** : 사용자가 요청한 SQL을 가장 빠르고 효율적으로 수행할 최적(최저비용)의 처리경로를 선택해 주는 DBMS의 핵심엔진이다.

## \[2] 캐싱된 SQL 공유

* 하드 파싱을 반복하지 않고 캐싱된 버전을 찾아 재사용하려면 캐시에서 SQL을 먼저 찾아야 한다.
* ⭐️ 이 때  캐시에서 SQL을 찾기 위해 사용되는 키 값이 **SQL 문장 그 자체**이다.⭐️

### (1) 실행계획이 공유되기 위한 조건

#### ⭐️SQL 수행절차⭐️

1. **문법적 오류와 의미상 오류**가 없는지 검사한다.
2. 해시 함수로부터 **반환받은 해시 값으로 라이브러리 캐시 내 해시버킷을 탐색한다. (**키 값 : **SQL 문장 그 자체)**
3. 찾아간 해시버킷에 **체인으로 연결된 엔트리를 차례로 스캔**하면서 같은 SQL 문장을 탐색한다.
4. SQL문장을 찾으면 함께 저장된 실행계획을 가지고 바로 **실행한다**.
5. 찾아간 해시 버킷에서 SQL 문장을 찾지 못하면 **최적화를 수행한다.**
6. 최적화를 거친 SQL과 실행계획을 방금 탐색한 **해시 버킷 체인에 연결한다.**
7. 방금 최적화한 실행계획을 가지고 **실행한다.**

### (2) ⭐️실행계획을 공유하지 못하는 경우⭐️

* ⭐ 문장상 의미가 같다면 **실행계획은 달라지지 않는다.**&#x20;
* 하지만 각각 **다른 캐시 공간**을 사용한다.⭐️

1. **⭐️ 공백 문자 또는 줄바꿈대소문자 구분**
2. **주석이 서로 다를 경우**
3. **테이블 Owner 명시**
4. **옵티마이져 힌트 사용**
5. **조건절 비교 값이 다를 경우**

## \[3] ⭐️ 바인드 변수 사용하기

* 모든 프로시저의 처리 루틴이 같다면 여러 개 생성하기보다 아래 처럼(링크 참조) 로그인 ID를 파라미터로 받아\
  하나의 프로시저로 처리하도록 하는 것이 효율적이다.
* ```sql
  SELECT * FROM CUSTOMER WHERE LOGIN_ID = :LOGIN_ID;
  ```
* 바인드 변수를 사용하면 **처음 수행한 세션**이 하드파싱을 통해 실행계획을 작성한다.
* **소프트 파싱** : 다른 세션들이 해당 SQL을 수행하면 라이브러리에 캐싱된  실행계획을 재사용하여 입력한 값만 새롭게 바인딩하면서 바로 실행한다.

### (1) ⭐️ 바인드 변수 사용의 이점

* 반복 수행되는 SQL과 실행계획을 재사용함으로써 파싱 소요 시간과 메모리 사용량을 줄여준다.
* 시스템 전반의 CPU 와 메모리 사용률을 낮추어주기에 데이터베이스 성능과 확장성을 높인다.

### (2) ⭐️ 바인드 변수 사용 안 해도 되는 경우

#### 아래 경우가 아니라면, 특히 OLTP 환경에선 반드시 바인드 변수를 사용할 것을 권고한다.

1. **정보계 시스템에서 사용되는 Long Running 쿼리**
   * 정보계 시스템 : 배치프로그램이나 DW, OLAP 등&#x20;
   * 파싱 소요시간이 총 소요시간에서 차지하는 비중이 낮다.
   * 수행빈도가 낮아 하드파싱에 의한 **라이브러리 캐시 부하 유발 가능성이 낮다.**
   * 그러므로 **상수조건절**을 사용하여 옵티마이저가 **컬럼히스토그램 정보를 활용**할수 있도록 유도하는것이 유리함
2. **조건절 컬럼의 값 종류(Distinct value)가 소수 일때**
   * 분포도가 좋지 않은 경우에는 옵티마이저가 **컬럼 히스토그램 정보를 활용**할수 있도록 유도한다.

#### 리터럴 SQL을 자동으로 변수화 시켜주는 기능

| ORACLE                                             |
| -------------------------------------------------- |
| **cursor\_sharing** 파라미터 : **force 또는 similar** 설정 |

* 이러한 기능은 부작용이 크므로 **되도록이면 사용을 자제**하고 바인드 변수를 사용하도록 한다.
* 각 DBMS는 조건절 비교 값이 리터럴 상수일 때 **이를 자동으로 변수화** 시켜주는 기능을 제공한다.

### (3) 바인드 변수 사용 시 주의사항

* **변수를 바인딩하는 시점이 최적화 이후**라는 사실을 알아야한다.
  * 즉, 나중에 **반복 수행될 때 어떤 값이 입력될지 알 수 없기 때문에 옵티마이저는 조건절 칼럼의 데이터 분포가 균일하다는 가정을 세우고 최적화를 수행**한다.
  * 따라서 **칼럼의 분포가 균일하지 않을때**에는 실행 시점에 바인딩되는 값에 따라 쿼리 성능이 다르게 나타날 수있다.
    * 이런 경우에는 **바인드 변수를 사용하지 않고** **상수값을 사용**하는 것이 낫다.

### (4) 바인드 변수 부작용을 극복하기 위한 노력

#### 1. oracle ‘바인드 변수 Peeking’

* SQL Server에서는 ‘Parameter Sniffing’이라고 한다.
* SQL이 **첫 번째 수행될 때의 바인드 변수 값을 살짝 훔쳐 보고**, 그 값에 대한 **칼럼 분포를 이용해 실행계획을 결정**하는 기능이다.
  * 실행계획이 수시로 바뀔 수 있기 때문에 위험한 기능이다.
*   쿼리 수행 전에 확인하는 실행계획은 바인드 변수 Peeking 기능이 적용되지 않은 실행계획이다.

    * 즉 실제 최적화 과정과는 다를 수가 있다.
    * 사용자가 쿼리 수행 전에 **실행계획을 확인할 때는 변수에 값을 바인딩하지 않으므로 옵티마이저는 변수 값을 Peeking 할 수 없다.**
    * 현재 대부분의 운영 시스템에서는 아래 처럼 바인드 변수 Peeking 기능을 비활성화시킨 상태에서 운영한다.

    ```sql
    alter system set ""_optim_peek_user_binds"" = FALSE ;
    ```

#### 2. oracle 11g ‘적응적 커서 공유(Adaptive Cursor Sharing)

* 특정 실행계획으로 실행했다가 바인드 변수에 다른 변수값이 입력됐을 때 **예상보다 많은 I/O가 발생**하면 다른 실행계획을 추가로 생성하고 이후에 바인드 **변수값 분포에 따라 다른 실행계획을 선택적으로 사용하는 기능**이다.
* 입력된 변수 값의 분포에 따라 다른 실행계획이 사용되도록 처리한다.

#### \[예시] 아파트 매물 테이블 조회

* 서울시와 경기도처럼 **선택도가 높은 값이 입력될 때는 Full Table Scan이 유리**하다.
* 강원도나 제주도처럼 **선택도가 낮은 값이 입력될 때는 인덱스를 경유해 테이블을 액세스하는 것이 유리**하다.

## \[4] Static SQL과 Dynamic SQL

* Static(=Embedded) SQL을 지원하는 개발 언어는 많지 않으며, PowerBuilder, PL/SQL, Pro\*C, SQLJ 정도가 있다.

### (1) Static SQL

* SQL문을 String형 변수에 담지 않고 코드 사이에 직접 기술한 SQL문이다.
* SQL문을 String 변수에 담지 않고 마치 예약된 키워드처럼 C/C++ 코드 사이에 섞어서 기술한다.
* Pro\*C에서 소스 프로그램(.pc)을 작성해서 PreCompiler로 PreCompile하면 순수 C/C++ 코드가 만들어진다.
  * 이 때 Static(=Embedded) SQL을 발견하면 이를 SQL 런타임 라이브러리에 포함된 함수를 호출하는 코드로 변환한 뒤 C/C++ Compiler로 Compile해 실행파일이 만들어지면 그것을 실행한다.
* 이 과정에서 **결국은 String형 변수에 담긴다.**
  * Static SQL이든 Dynamic SQL이든 PreCompile 단계를 거치고 나면 String 변수에 담기기는 마찬가지이다.
* Static SQL을 지원하는 애플리케이션이라면 사용하는 것을 권고 !
* Static SQL은 런타임 시에 절대 변하지 않으므로 PreCompile 단계에서 구문 분석, 유효 오브젝트 여부, 오브젝트 액세스 권한 등을 체크하는 것이 가능하다.

### (2) ⭐️ Dynamic SQL

* SQL문을 String형 변수에 담아서 기술하는 SQL문이다.
* **런타임 시에 사용자로부터 SQL문의 일부 또는 전부를 입력 받아**서 실행할 수도 있음
* PreCompile 시 Syntax, Semantics 체크가 불가능하므로 Dynamic SQL에 대해선 PreCompiler는 내용을 확인하지 않고 그대로 DBMS에 전달한다.

#### ⭐ SQL문을 String형 변수에 담아서 기술된 형태인 경우 ⭐&#x20;

* &#x20;인덱스 전략 수립이 어렵다.
* 실행계획을 제어하기 어렵다.
* 테이블 통계정보는 사용 가능하다.
* 바인드 변수 사용으로 하드파싱 많이 안 일어난다.

### (3) 바인드 변수의 중요성 재강조

* 라이브러리 캐시 효율을 논할 때 Static이냐 Dynamic이냐의 차이보다는 바인드 변수 사용 여부에 초점을 맞춰야 한다.
* Static, Dynamic SQL은 애플리케이션 개발 측면에서의 구분일 뿐이다.
  * 데이터베이스 입장에선 차이가 없다.
  * Static SQL을 사용하든 Dynamic SQL을 사용하든 옵티마이저는 SQL 문장 자체만 인식할 뿐이므로 성능에도 영향을 주지 않는다.

## \[5] ⭐ 애플리케이션 커서 캐싱

* **soft parsing을 일으키지 않고** 빠르게 sql을 수행할수 있는 방법이다.

> ✅ **soft 파싱의 비효율성**
>
> **다음 일련의** 작업을 매번 반복해야 하므로 비효율이 발생한다.
>
> 1. SQL 문장의 문법적, 의미적 오류가 없는지 확인한다.
> 2. &#x20;해시함수로부터 반환된 해시 값을 이용해 캐시에서 실행계획을 찾는다.
> 3. &#x20;수행에 필요한 메모리 공간 (Persistent Area와 Runtime Area)을 할당한다.
> 4. 등등..&#x20;

* 일반적인 방식으로 같은 SQL을 반복 수행할 때는 Parse Call 횟수가 Execute Call 횟수와 같다.
* ⭐ **애플리케이션 커서 캐싱 수행시 Parse Call은 한 번만 발생하고 이후 반복 수행할 때는 Parse Call이 전혀 발생하지 않는다.** ⭐&#x20;
