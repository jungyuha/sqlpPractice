# 1. 데이터베이스 아키텍처

**기록 ✍️**

#### author : jung yuha

#### **first Registered : 2022-04-12**

#### last modified : **2022-04-12**

## \[1] 성능튜닝의 3대 요소 <a href="#1-3" id="1-3"></a>

### (1) sql파싱부하해소 <a href="#1-sql" id="1-sql"></a>

### (2) 데이터베이스 call최소화 <a href="#2-call" id="2-call"></a>

### (3) I/O효율화 <a href="#3-io" id="3-io"></a>

## \[2] 인스턴스 <a href="#2" id="2"></a>

**SGA 공유메모리 영역과 이를 액세스하는 프로세스 집합이다.**

![](https://velog.velcdn.com/images/yooha9621/post/7d539993-9c07-4b7a-a98e-bb8b3a8522a4/image.png)

### (1) 기본적으로 하나의 인스턴스가 하나의 데이터베이스를 액세스한다. <a href="#1" id="1"></a>

* RAC환경에서는 여러 인스턴스가 하나의 데이터베이스를 엑세스 가능
* 하나의 인스턴스가 여러 데이터 베이스를 액세스는 불가능

## \[3] 프로세스 <a href="#3" id="3"></a>

**서버 프로세스 + 백그라운드 프로세스**

### (1) 서버프로세스 <a href="#1" id="1"></a>

* 사용자 프로세스와 통신하면서 사용자의 각종 명령을 처리한다.
* SQL Server는 Worker 쓰레드로 표현한다.

#### 1. 서버 프로세스가 하는 일 <a href="#1" id="1"></a>

* sql파싱하고 최적화하고 블록을 읽고 네트워크를 통해 결과를 전송하는 일련의 작업을 수행한다.
* 데이터 파일로 부터 DB 버퍼 캐시로 블록을 적재한다.
* 블록을 캐시에서 밀어냄으로써 Free 블록을 확보한다.
* Redo 로그 버퍼 비우기 등

#### 2. 서버 프로세스로의 연결 요청 이슈 <a href="#2" id="2"></a>

* (_1_) sql을 수행할때마다 연결요청을 반복하면 서버의 성능저하가 있기에 Connection Pooling 기법이 필수이다.(반복재사용)
  * (_1_) 이 때 , Connection Pooling 기법시 Connection을 닫는 게 아니다.
* (_1_) 연결 요청에 대한 부하는 쓰레드 기반 아키텍처보다 프로세스 기반 아키텍처에 부하가 더 크다.

#### 3. 서버 프로세스의 종류 <a href="#3" id="3"></a>

**종류1) 공유 서버 방식**

![](https://velog.velcdn.com/images/yooha9621/post/788961ca-31ba-4a35-b47b-e071a07313d3/image.png)

* 하나의 서버 프로세스를 여러 사용자 세션이 공유한다.
  * Connection Pooling 기법
* 미리 여러개의 서버 프로세스를 띄어놓고 이를 공유해서 반복 재사용한다.
*   (_1_) 사용자 프로세스는 서버 프로세스와 직접 통신하지 않고 Dispatcher 프로세스를 거친다.

    > **✅ 공유 서버 작동 방식(순서)**
    >
    > 1. 사용자 명령이 Dispatcher에게 전달된다.
    > 2. Dispatcher는 이를 SGA에 있는 요청 큐(Request Queue)에 등록한다.
    > 3. 이후 가장 먼저 가용해진 서버 프로세스가 요청 큐에 있는 사용자 명령을 꺼내서 처리한다.
    > 4. 그 결과를 응답 큐(Response Queue)에 등록한다.
    > 5. 응답 큐를 모니터링하던 Dispatcher가 응답 결과를 발견하면 사용자 프로세스에게 전송한다.

**종류2) 전용 서버 방식**

![](https://velog.velcdn.com/images/yooha9621/post/1d826841-4d5e-43ee-bdf9-a71adf388702/image.png)

* 서버 프로세스가 단 하나의 사용자 프로세스를 위해 전용(Dedicated) 서비스를 제공한다.
*   SQL을 수행할 때마다 연결 요청을 반복하면 (_1_) 서버 프로세스의 생성과 해제도 반복하게 되므로 DBMS에 매우 큰 부담을 주고 성능을 크게 떨어뜨린다.\
    \- OLTP성 애플리케이션에선 Connection Pooling 기법을 필수적으로 사용해야 한다.

    > **✅ 전용 서버 작동 방식(순서)**
    >
    > 1. 사용자는 리스너에 연결을 요청한다.
    > 2. 리스너는 서버로 프로세스를 생성하고 연결 요청을 상속한다.
    > 3. 서버는 사용자에게 패킷을 전송한다.
    > 4. 연결 후 사용자는 서버로 작업을 요청한다.
    > 5. 서버는 사용자에게 결과를 전송한다.

### (2) 백그라운드 프로세스 <a href="#2" id="2"></a>

#### 1) 백그라운드 프로세스 종류 <a href="#1" id="1"></a>

* System Monitor(SMON): 장애후 재기동에 인스턴스 복구하고 임시 세그먼트와 익스텐트를 모니터링한다.
* Process Monitor(PMON) : 이상이 생긴 프로세스가 사용하던 리소스를 복구시킨다.
* Database Writer(DBWn) : 버퍼캐시의 Dirty버퍼를 데이터파일에 기록한다.
* Log Writer : 로그버퍼 엔트리를 Redo로그 파일에 저장한다.
* Arvhiver : Redo로그가 덮어쓰여지기 전에 Archiver로그로 백업한다.
* chechkpoint : 이전 CheckPoint 이후의 변경 사항을 데이터 파일에 기록하도록 트리거링한다.
  * 이전에 Checkpoint가 일어났던 마지막 시점 이후의 데이터베이스 변경 사항을 데이터 파일에 기록하도록 트리거링한다.
  * 기록이 완료되면 현재 어디까지 기록했는지를 컨트롤 파일과 데이터 파일 헤더에 저장한다.
  * Write Ahead Logging 방식(데이터 변경 전에 로그부터 남기는 메커니즘)을 사용하는 DBMS는 Redo 로그에 기록해 둔 버퍼 블록에 대한 변경사항 중 현재 어디까지를 데이터 파일에 기록했는지 체크포인트 정보를 관리해야 한다.
  * 이는 버퍼 캐시와 데이터 파일이 동기화된 시점을 가리키며, 장애가 발생하면 마지막 체크포인트 이후 로그 데이터만 디스크에 기록함으로써 인스턴스를 복구할 수 있도록 하는 용도로 사용된다.
  * 이 정보를 갱신하는 주기가 길수록 장애 발생 시 인스턴스 복구 시간도 길어진다.
* Recover : 분산 트랜잭션 문제를 해결한다.
