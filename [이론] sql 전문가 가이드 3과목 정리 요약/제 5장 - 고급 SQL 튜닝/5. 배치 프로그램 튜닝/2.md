# 배치 프로그램 튜닝(2)

**기록 ✍️**

#### author : jung yuha

#### **first Registered : 2022-04-12**

#### last modified : **2023-05-05**

## \[1] 병렬 처리 활용

* SQL문이 수행해야 할 작업 범위를 여러 개의 작은 단위로 나누어 여러 프로세스(또는 쓰레드)가 동시에 처리하는 것
* 여러 프로세스가 동시에 작업하므로 대용량 데이터를 처리할 때 수행 속도를 극적으로 단축

```sql
 select /*+ full(o) parallel(o, 4) */
 count(*) 주문건수, sum(주문수량) 주문수량, sum(주문금액) 주문금액
 from 주문 o
 where 주문일시 between '20100101' and '20101231';

 select /*+ index_ffs(o, 주문_idx)) parallel_index(o, 주문_idx, 4) */
 count(*) 주문건수 
 from 주문 o
 where 주문일시 between '20100101' and '20101231';
```

* parallel 힌트를 사용할 때는 반드시 Full 힌트도 함께 사용하는 습관이 필요하다.
  * 옵티마이저에 의해 인덱스 스캔이 선택되면 parallel 힌트가 무시되기 때문이다.
* parallel\_index 힌트를 사용할 때, 반드시 index 또는 index\_ffs 힌트를 함께 사용하는 습관도 필요하다.
  * 옵티마이저에 의해 Full Table Scan이 선택되면 parallel\_index 힌트가 무시되기 때문이다.

### (1) Query Coordinator와 병렬 서버 프로세스

#### 1. Query Coordinator(이하 QC)

* 병렬 SQL문을 발행한 세션
* 병렬 서버 프로세스는 실제 작업을 수행하는 개별 세션들이다.

**QC의 역할**

```sql
select /*+ ordered use_hash(d) full(d) full(e) noparallel(d) parallel(e 4) */
count(*), min(sal), max(sal), avg(sal), sum(sal)
from dept d, emp e
where d.loc = 'CHICAGO' and e.deptno = d.deptno; 
```

* 병렬 SQL이 시작되면 QC는 사용자가 지정한 병렬도(DOP, degree of parallelism)와 오퍼레이션 종류에 따라 하나 또는 두 개의 병렬 서버 집합(Server Set)을 할당
* 우선 서버 풀(Parallel Execution Server Pool)로부터 필요한 만큼 서버 프로세스를 확보하고, 부족분은 새로 생성한다.
* QC는 각 병렬 서버에게 작업을 할당한다.
* 작업을 지시하고 일이 잘 진행되는지 관리감독하는 작업반장 역할.
* 병렬로 처리하도록 사용자가 지시하지 않은 테이블은 QC가 직접 처리한다.
* QC는 각 병렬 서버로부터의 산출물을 통합하는 작업을 수행한다.
  * 예를 들어 집계 함수(sum, count, avg, min, max 등)가 사용된 병렬 쿼리를 수행할 때, 각 병렬 서버가 자신의 처리 범위 내에서 집계(4번 단계)한 값을 QC에게 전송(3번 단계)하면 QC가 최종 집계 작업을 수행(1번 단계)한다.
* QC는 쿼리의 최종 결과집합을 사용자에게 전송하며, DML일 때는 갱신 건수를 집계해서 전송해 준다.
* 쿼리 결과를 전송하는 단계에서 수행되는 스칼라 서브쿼리도 QC가 수행한다.

### (2) Intra-Operation Parallelism과 Inter-Operation Parallelism

![](https://velog.velcdn.com/images/yooha9621/post/6aa5779e-53e8-4f39-bfc1-98cbdd5e5ab5/image.png)

```sql
select /*+ full(고객) parallel(고객 4) */ *
from 고객
order by 고객명;
```

#### 1. Intra-Operation Parallelism

* 서로 배타적인 범위를 독립적으로 동시에 처리하는 것
* 첫 번째 서버 집합(P000\~P003)에 속한 4개의 프로세스가 범위를 나눠 고객 데이터를 읽는 작업
* 두 번째 서버 집합(P004\~P007)이 첫 번째 서버 집합으로부터 전달받은 고객 데이터를 정렬하는 작업
* 한 병렬 서버 집합(Server Set)에 속한 여러 프로세스가 처리 범위를 달리하면서 병렬로 작업을 진행하는 것이므로 집합 내에서는 절대 프로세스 간 통신이 발생하지 않는다.

#### 2. Inter-Operation Parallelism

* 같은 서버 집합끼리는 서로 데이터를 반대편 서버 집합에 분배하거나 정렬된 결과를 QC에게 전송하는 작업을 병렬로 동시에 진행하는 것.
* 이때는 항상 프로세스 간 통신이 발생한다.
  * 메시지 또는 데이터를 전송하기 위한 통신 채널이 필요하다.

#### 3. 테이블 큐

```sql
select /*+ ordered use_hash(e) full(d) noparallel(d) full(e) parallel(e 2) pq_distribute(e broadcast none) */ *
from dept d, emp e
where d.deptno = e.deptno
order by e.ename;
```

![](https://velog.velcdn.com/images/yooha9621/post/f6141837-31c9-4f25-8385-aad887e0fe9a/image.png)

* Inter-Operation Parallelism에서 쿼리 서버 집합 간(P→P) 또는 QC와 쿼리 서버 집합 간(P→S, S→P) 데이터 전송을 위해 연결된 파이프 라인(Pipeline)
* 각 테이블 큐에 부여된 :TQ10000, :TQ10001, :TQ10002와 같은 이름을 ‘테이블 큐 식별자(TQ Identifier)’라고 한다.
* 쿼리 서버 집합 간(P→P) Inter-Operation Parallelism이 발생할 때는 사용자가 지정한 병렬도(=2)의 배수(4개)만큼 서버 프로세스가 필요하다.
* 또한 테이블 큐(:TQ10001)에는 병렬도의 제곱(2^2=4)만큼 파이프 라인이 필요하다는 사실도 알 수 있다.
* 참고로 그림 Ⅲ-5-15를 보면, 병렬도가 4이므로 8(=4×2)개 서버 프로세스를 위해 16(=4^2)개의 파이프 라인이 형성되었다.

**생산자 / 소비자 모델**

* 테이블 큐에는 항상 생산자(Producer)와 소비자(Consumer)가 존재한다.
* 처음 dept 테이블을 읽어 분배하는 :TQ10000에서는 QC가 생산자고 서버 집합 1이 소비자다.
* 이어지는 두 번째 테이블 큐 TQ10001에서는 서버 집합 1이 생산자가 되고, 서버 집합 2가 소비자.
* 마지막으로, 정렬된 최종 결과집합을 전송하는 :TQ10002에서는 서버 집합 2가 생산자가 되고 QC가 소비자.
* select 문장에서의 최종 소비자는 항상 QC일 것.
* \[그림 Ⅲ-5-16]에서 보듯 Inter-Operation Parallelism이 나타날 때, 소비자 서버 집합은 from절에 테이블 큐를 참조하는 서브(Sub) SQL을 가지고 작업을 수행한다.

#### 4. IN-OUT 오퍼레이션

* S→P, P→S, P→P는 프로세스 간 통신이 발생한다.

**S→P**

* QC가 처리한 결과를 병렬 서버 프로세스에 전달
* 직렬(Serial) 오퍼레이션

**P→S**

* 병렬 서버 프로세스가 처리한 결과를 QC에 전달
* 병렬 오퍼레이션

**P→P**

* 두 개의 병렬 서버 프로세스 집합이 처리
* 지정한 병렬도의 2배 만큼의 병렬 프로세스 생성
* 병렬 오퍼레이션

**PCWP와 PCWC**

* 프로세스 간 통신이 발생하지 않음
* 각 병렬 서버가 독립적으로 여러 스텝을 처리할 때 나타난다.
* 하위 스텝의 출력 값이 상위 스텝의 입력 값으로 사용된다.

**PCWP**

* 병렬 서버 프로세스 집합이 현재 스텝과 그 부모 스텝을 모두 처리
* 병렬 오퍼레이션

**PCWC**

* 병렬 서버 프로세스 집합이 현재 스텝과 그 자식 스텝을 모두 처리
* 병렬 오퍼레이션

#### 5. 데이터 재분배

병렬 서버 프로세스 간에 데이터를 재분배하는 방식

**RANGE**

* order by 또는 sort group by를 병렬로 처리할 때 사용된다.
* 두 번째 서버 집합 : 정렬 작업을 맡음
* 프로세스마다 처리 범위(예를 들어, A~~G, H~~M, N~~S, T~~Z)를 지정한다.
* 데이터를 읽는 첫 번째 서버 집합이 두 번째 서버 집합의 정해진 프로세스에게 “정렬 키 값에 따라” 분배하는 방식
* QC의 역할
  * 각 서버 프로세스에게 작업 범위를 할당
  * 정렬 작업에는 직접 참여하지 않음
  * 정렬이 완료되고 나면 순서대로 결과를 받아서 사용자에게 전송
  * P→P 뿐만 아니라 S→P 방식으로 이루어질 수도 있음

**BROADCAST**

* QC 또는 첫 번째 서버 집합에 속한 프로세스들
* 각각 읽은 데이터를 두 번째 서버 집합에 속한 “모든” 병렬 프로세스에게 전송하는 방식
* 병렬 조인에서 크기가 매우 작은 테이블이 있을 때 사용
* P→P 뿐만 아니라 S→P 방식으로도 이루어진다.

**KEY**

* 특정 칼럼(들)을 기준으로 테이블 또는 인덱스를 파티셔닝할 때 사용하는 분배 방식

**ROUND-ROBIN**

* 파티션 키, 정렬 키, 해시 함수 등에 의존하지 않고 반대편 병렬 서버에 무작위로 데이터를 분배할 때 사용
