출처 : SQLP 기출노트 1권 ( p.17 ~ p.36)
### ✍️ 11번 : SQL 언어의 특징
#### SQL : Structured Query Language
1. **구조적 ( = Structured )**
2. **집합적 ( = Set-based )**
3. **선언적 ( = declarative )**

#### 🍋 기출 포인트
1. **⭐️ 절차적(Procedural) 특징이 SQL의 특징은 아니다. ⭐️**
- SQL에서 오라클 PL/SQL , SQL Server T-SQL 처럼 절차적 프로그래밍이 가능하나 이 자체가 SQL의 특징은 아니다.

### ✍️ 12,13번 : SQL 처리 과정
#### SQL 처리과정 : 크게 3단계 ( 파싱 > 최적화 > 로우소스 )
1. **⭐️ SQL 파싱⭐️**
- SQL 파싱 단계에서는 테이블 정보 , 컬럼 정보 , 권한 정보 등을 활용한다.
- SQL 파싱 순서
    1. 파싱 트리 생성 : 개별 구성 요소 분석해서 파싱 트리를 생성
    2. ⭐️ Syntax 체크 : 문법적 오류 체크
    - 사용할 수 없는 키워드
    - 잘못된 순서
    - 누락된 키워드
    3. ⭐️ Semantic 체크 : 의미상 오류 체크
    - 존재하지 않는 테이블
    - 오브젝트 퀀한
2. **SQL 최적화**
- SQL 옵티마이저가 역할을 맡는다.
- 데이터 딕셔너리에 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성한다.
3. **로우소스 생성**
- 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅한다.
- 로우 소스 생성기가 역할을 맡는다.
#### 🍋 기출 포인트
1. **⭐️ SQL에 문법적 오류 또는 의미상 오류가 없는지는 SQL 파싱 단계에서 이루어진다. ⭐️**
1. **⭐️ SQL 파싱 단계에서는 테이블 정보 , 컬럼 정보 , 권한 정보 등을 활용하고
SQL 최적화 단계에서는 오브젝트 통계 정보 및 시스템 통계를 활용한다. ⭐️**

### ✍️ 15번 : 옵티마이저 힌트가 무시되는 특별한 이유
#### 옵티마이저 힌트가 무시되는 특별한 이유
1. **문법적으로 맞지 않게 힌트를 기술**
2. **잘못된 참조 사용**
- 없는 테이블 사용 
- 없는 테이블 별칭 사용
- 없는 인덱스명 사용
3. **논리적으로 불가능한 액세스 경로**
- 조인절에 등치 조건이 하나도 없는데 해시 조인으로 유도한 경우
- 테이블 전체 건수를 카운트하는 쿼리에 NULL을 허용하는 단일 컬럼으로 생성한 인덱스를
사용하도록 지정한 경우
4. **의미적으로 맞지 않게 힌트 기술**
5. **옵티마이저에 의해 내부적으로 쿼리가 변환**
6. **버그**
#### 옵티마이저 힌트가 무시되지 않는 경우
1. index 힌트에 인덱스 명을 지정하지 않은 경우
- 어떤 인덱스를 사용하지를 옵티마이저가 결정한다.
2. leading 힌트에 테이블을 나열하지 않은 경우
- 조인순서는 옵티마이저가 결정한다.

#### 🍋 기출 포인트
1. **⭐️ index 힌트에 인덱스 명을 지정하지 않아도 힌트가 무시되지 않는다. ⭐️**

### ✍️ 19번 : 블록 단위 I/O와 로우 단위 I/O
#### 블록 단위 I/O : 버퍼캐시와 데이터 파일 I/O 모두 적용된다.
1. **데이터 파일 > 버퍼캐시로 블록 적재** 
2. **데이터 파일에서 블록을 직접 읽고 쓸 때 (Direct Path I/O)** 
3. **버퍼캐시에서 블록을 읽고 쓸 때**
4. **버퍼캐시 > 데이터파일로 데이터를 쓸 때 ** 
#### 로우 단위 I/O
1. 저장된 테이블 및 컬럼 정보를 딕셔너리 캐시에 적재될 때
  - 딕셔너리 캐시를 로우 캐시라고 부르기도 한다. 
#### 🍋 기출 포인트
1. **⭐️ 딕셔너리 캐시는 블록 단위가 아니라 로우 단위로 I/O한다. ⭐️**

### ✍️ 22번 : 버퍼캐시 히트율 공식 (BCHR)
#### 버퍼캐시 히트율 공식
1. **( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 )x 100 **
2. **((논리적 I/O - 물리적 I/O)/논리적 I/O)x100**
3. **(1-(물리적 I/O)/(논리적 I/O))x100**

#### 논리적 I/O
- 수행 과정에서 읽은 총 블록수
- query 항목과 current 항목의 합이다.
  - query 항목은 consistent 모드로 읽은 블록 수이다.
  - current 항목은 current 모드로 읽은 블록 수 이다.
- 논리적 I/O 횟수에는 물리적 I/O 횟수가 포함되어있다.

#### 🍋 기출 포인트
1. **⭐️ 논리적 I/O 횟수에는 물리적 I/O 횟수가 포함되어있다. ⭐️**
2. **⭐️ 논리적 I/O는 query 항목과 current 항목의 합이다. ⭐️**

### ✍️ 24번 : 시퀀셜 액세스와 랜덤 액세스
#### 시퀀셜 액세스
- 논리적으로 연결된 순서에 따라 차례로 블록을 읽어나가는 방식
- 물리적으로 연결된 순서에 따라 차례로 블록을 읽어나가는 방식
- 인덱스와 테이블을 **스캔**할 때 이 방식을 사용한다.

#### 랜덤 액세스
- 논리적 , 물리적인 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식

#### 🍋 기출 포인트
1. **⭐️ 인덱스를 스캔하면서 얻은 ROW ID로 테이블 블록을 액세스하는 단계가 랜덤 액세스에 해당한다. ⭐️**

### ✍️ 25,26번 : Single Block I/O
#### Single Block I/O : 인덱스를 이용할 때 기본적으로 사용되는 방식
- 인덱스 루트 블록 읽을 떄
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

#### Multi Block I/O : Full scan할 때 기본적으로 사용되는 방식
- 테이블을 Full Scan할 때
- 인덱스를 Fast Full Scan할 때 
- 디스크 상에 그 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능
  - 인접한 블록 : 같은 익스텐트에 속한 블록
- I/O 단위는 db_file_multiblock_read_count 파라미터에 의해 결정됨
  - 아무리 늘린다해도 익스텐트의 경계를 넘지 못함


#### 🍋 기출 포인트
1. **⭐️ db file sequential read 대기 이벤트는 Single Block I/O할 때 나타난다. ⭐️**
2. **⭐️ db file scattered read 대기 이벤트는 multi Block I/O할 때 나타난다. ⭐️**
3. **⭐️ multi Block I/O는 한 익스텐트 안에서 이루어진다. 즉, 한 익스텐트에 속한 마지막 블록을 읽었는데 아직 Multi block I/O 단위를 다 못채웟어도 다음 익스텐트를 추가로 읽지는 않는다. ⭐️**
4. **⭐️ multi Block I/O시 작은 Extent로 구성된 테이블이라면 I/O Call이 더 많이 발생한다. ⭐️**
5. **⭐️ 인덱스를 이용해 테이블을 읽을 때는 Single block I/O 형식이므로 익스텐트 크기에 따라 I/O Call 횟수가 달라지지 않는다. ⭐️**
