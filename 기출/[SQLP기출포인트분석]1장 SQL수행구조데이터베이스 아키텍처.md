# 1) 데이터베이스 아키텍처

### ✍️ 2번 : 각 백그라운드 프로세스의 역할 구분하기

> **✅ 백그라운드 프로세스**

**1. System Monitor ( = SMON )**

* 오라클에서 사용되는 인스턴스의 상태를 감시하는 백그라운드 프로세스
* **장애가 발생한 시스템을 재기동할 때 인스턴스 복구**(instance recovery)를 수행
* 임시 세그먼트와 익스텐트를 모니터링
* UNDO 세그먼트를 관리합니다. (크기가 커진 UNDO 세그먼트 축소 등)
* 다 사용한 Temp 세그먼트를 정리합니다.

> **2. Process Monitor( = PMON )**

* 이상이 생긴 **프로세스가 사용하던 리소스를 복구**
* 오라클에서 사용되는 프로세스를 정기적으로 관리하고 감시하는 프로세스
* 비정상적으로 종료된 세션이 있다면 처리중이었던 데이터를 복구하고 정리하는 역할을 합니다.
* 디스패치 프로세스와 서버 프로세스의 상태를 정기적으로 체크하고 실행이 정지된 프로세스가 있다면 재기동합니다.
* 인스턴스와 디스패처 프로세스에 관한 정보를 리스너에 자동적으로 등록합니다.

> **3. Database Writers( = DBWR )**

* **DB buffer cache**에 있는 내용을 **data file(disk)에** 내려쓰는 프로세스
* 내려씀으로써 DB buffer cache를 free 상태로 만들어 다시 사용할 수 있게 해줍니다.

> **4. Archiver( = ARCn )**

* 꽉찬 Redo 로그가 덮어 쓰여지기 전에 **Archive 로그 디렉토리로 백업**한다.

> **5. CheckPoint ( = CKPT )**

* 이전에 checkpoint가 일어났던 마지막 시점 이후의 데이터베이스 변경 사항을 데이터 파일에 기록하도록 트리거링
  * 기록 완료 후 현재 어디까지 기록했는지 컨트롤 파일과 데이터파일 헤더에 저장
    * 버퍼캐시와 데이터 파일이 동기화된 시점 이다.
* Write ahead logging 방식을 사용하기 때문에 리두로그에 기록해둔 버퍼 블록에 대한 변경 사항 중 **어디까지 데이터 파일에 기록했는지 체크포인트 정보를 관리**해야함
  * Write ahead logging 방식 : 데이터 변경 전 로그부터 남기는 메커니즘
* 장애가 발생하면 마지막 체크포인트 이후 로그 데이터만 디스크에 기록함으로써 인스턴스를 복구할 수 있는 용도로 사용된다.
* 이 정보를 갱신하는 주기가 실수록 장애 발생시 인스턴스 복구 시간도 길어진다.

> **6. Recover ( = RECO )**

* 분산 트랜잭션 과정에 발생한 문제를 해결한다.

#### 🍋 기출 포인트

1. **⭐️ 서버 프로세스와의 역할 구분 ⭐️**

#### 사용자 프로세스

```
- **로그 버퍼**에 로그를 기록하는 것은 DML을 수행하는 **각 사용자 프로세스**이다.
- 사용자 프로세스는 **로그버퍼에 로그를 기록**하고 **데이터 블록을 변경**한다.
```

#### 백그라운드 프로세스

```
- 그 이후 **LGWR 백그라운드 프로세스**가 주기적으로 **로그 버퍼 엔트리를 Redo 로그 파일에 기록**한다.
```

### ✍️ 5번 : Undo를 사용하는 목적

#### Undo를 사용하는 목적 : 각 트랜잭션이 사용하는 리소스와 관련하여 사고하도록 한다.

1. **Transaction Rollback** (트랜잭션 롤백)
2. **Transaction Recovery** (트랜잭션 복구)

* 인스턴스 복구시 트랜잭션 복구 이후 트랜잭션을 롤백하는 데에 쓰인다.

1. 오라클의 \*\* ⭐️문장 수준 읽기 일관성⭐️ \*\* ( Read Consistency )

### ✍️ 6번 : Redo를 사용하는 목적

#### Redo를 사용하는 목적 : 각 트랜잭션보다 더 큰 범위인 다수가 공유하는 범위인 데이터베이스로 사고한다.

1. **Database Recovery ( = Media Recovery )** (데이터베이스 복구)

* 이 때 Archived Redo 로그를 이용한다.

1. **Cache Recovery** (버퍼 캐시,인스턴스 복구)

* 인스턴스 복구시 인스턴스 상태를 Roll Forward하는 데에 쓰인다.
* 버퍼 캐시에만 적용한 변경 사항 , 아직 데이터 파일에 기록되지 않은 상태의 트랜잭션 데이터 유실에 대비하기 위해 Redo 로그를 남김

> **🔥 헷갈리지 않기 : 버퍼 캐시와 Redo 로그는 엄연히 다른 개념이다!!**
>
> * Redo 로그는 버퍼 캐시의 변경 사항을 기록하는 곳으로 버퍼 캐시의 상태의 복구하거나 Roll Forward하거나 Fast commit 하는 데에 사용된다.
> * Redo 로그에 **데이터 자체**가 저장되는 게 아님! **상태 변화**를 기록하는 거임 !

1. 오라클의 \*\* ⭐️Fast Commit⭐️ \*\*

* **Fast commit**은 '**Redo**' 키워드와 짝꿍이다.
* 변경된 메모리 버퍼 블록을 파일에 기록하는 작업은 Random 액세스로 진행된다. 그리고 이 작업은 매우 느리다.
* 우선 **Append 방식으로 빠르게 로그 파일에 기록**한 후 버퍼 캐시와 데이터 블록 간의 동기화는 적절한 수단을 이용해 **나중에 일괄(Batch)로 수행**한다.

#### 🍋 기출 포인트

1. **⭐️ Redo 로그의 스위칭 주기 ⭐️**

* 스위칭 주기가 짧으면 DB Hang이 발생할 수 있다. 따라서 스위칭이 자주 발생하지 않는 게 좋다.

### ✍️ 7번 : Redo 메커니즘

#### Redo 메커니즘 :

1. **Log Force at Commit**

* DML수행하는 사용자 프로세스가 로그 버퍼에 로그를 기록하고 데이터 블록을 변경
  * ⭐️ 즉, \*\*로그 기록 -> 데이터 블록 변경 \*\* ⭐️
* 이후 LGWR가 주기적으로 로그 버퍼 엔트리를 Redo로그 파일에 기록
* 트랜잭션의 영속성을 보장하기 위해 **최소 커밋 시점에**는 로그를 **메모리가 아닌 데이터파일에** 안전하게 기록해야함을 의미
  * ⭐️ 즉, 안전한 로깅은 **메모리가 아니라 파일에** 해야한다는 소리임! ⭐️

1. **Fast Commit**

* 사용자가 요구한 갱신 사항을 버퍼캐시에만 기록한 채 아직 디스크에 영구 기록 하지 않아도 \*\* ⭐️ Redo 로그(데이터 파일에 위치)\*\*를 믿고 빠르게 커밋을 완료 ⭐️한다는 의미
* 커밋 정보가 로그 파일에 기록되어 있기만 하면 인스턴스가 유실되어도 복구가 가능함

1. **Write Ahead Logging**

* 버퍼 캐시 블록을 갱신하기 전에 먼저 Redo 엔트리를 로그 버퍼에 기록해야함
* DBWR가 Dirty 블록들을 데이터 파일에 기록하기 전에 먼저 LGWR가 Redo 엔트리를 모두 Redo 로그 파일에 기록했음이 보장되어야함
* 즉 , 로그 버퍼 기록 > 버퍼 캐시 갱신 그리고

### ✍️ 8번,9번 : SGA 구성요소

#### 1) SGA 구성요소

1. **DB 버퍼 캐시**

* 캐싱 목록
  * 테이블 블록
  * 인덱스 블록
  * Undo 블록

1. **딕셔너리 캐시**

* 캐싱 목록
  * 테이블 정보
  * 인덱스 정보
  * 데이터파일 정보
  * 시퀀스 (시퀀스는 따로 저장공간이 없고 캐싱이 된다 !)

1. **라이브러리 캐시**

* 캐싱 목록
  * DB 저장형 함수/프로시저
  * 트리거
  * SQL

1. **Result 캐시**

* SQL 결과 집합을 캐싱

1. **로그 버퍼**

#### 2) PGA 구성요소

1. **소트 영역 (SORT AREA)**

#### 🍋 기출 포인트

1. **⭐️ SORT AREA는 SGA 영역(공유 영역)이 아니다 ! ⭐️**
2. **⭐️ SQL은 딕셔너리 캐시가 아니라 라이브러리 캐시에 위치한다 ! ⭐️**

> **🌸 키워드 짝꿍**
>
> 1. `Fast commit` 과 `Redo`
> 2. `Archived Redo 로그` 과 `미디어 복구`
> 3. `Log Force at Commit` 과 `Redo`
> 4. `Write ahead Logging` 과 `Redo`
> 5. `Snapshot Too Old` 와 `Undo`
> 6. `Fast commit` 과 `Redo`
