# 블록 클린아웃이란?
- 트랜잭션에 의해 설정된 로우 Lock을 해제하고 블록 헤더에 커밋 정보를 기록하는 오퍼레이션
- 단어 뜻 고~대로 말그대로 블록청소를 뜻한다!
- 트랜잭션 커밋 시 블록 클린아웃까지 완료 해야 하나, 대량 갱신 작업의 경우 빠른 커밋을 위해 커밋 정보를 트랜잭션 테이블에만 기록하고 커밋 처리 하는 경우가 있다.
# 1. 들어가기 앞서 .. 다시 한 번 용어 정리😎
 - 로우 단위 Lock은 레코드 속성(Lock Byte)이 관리한다.
   - Lock Byte는 블록 헤더에 있는 ITL 엔트리를 가리키는 로우 헤더에 위치한 포인터이다.
- 블록 헤더 ITL 슬롯 (24 Byte)은 테이블/인덱스의 블록 헤더에 위치하며 Interested Transaction List의 약자이다.
- Last UBA는 Undo Block Address의 약자로 undo 헤더의 트랜잭션 테이블 슬롯에 위치한다.
# 2. 트랜잭션이 돌아가는 순서
  1. DML을 수행하기 위해 트랜잭션을 시작한다.
  2. online Undo Segment 할당을 시도한다.
    -  할당이 안되는 경우 **enq:US-Contention** 대기 이벤트가 발생한다.
  3. Undo Segment Header에 트랜잭션 테이블 슬롯이 생성된다.
  4. TXID(트랜잭션 아이디)를 생성하고 트랜잭션을 할당한다.
  5. 트랜잭션 대상이 되는 블록들을 버퍼 캐시로 적재한다.
  6. ITL 엔트리 등록 공간이 넉넉한지 확인한다.
    -  할당이 안되는 경우  **enq:TX-allocate ITL entry** 대기 이벤트가 발생한다.
  7. 블록 헤더의 ITL에 트랜잭션 Entry를 등록한다.
  8. 변경 블록 정보는 PGA에 체인지 벡터명으로 저장된다.
  9. 프로세스는 PGA의 체인지 벡터들을 리투 레코드(리두 엔트리)라는 이름으로 리두 버퍼에 복사한다.
  10. 이전 이미지(before Image)에 대한 정보를 언두 블록에 기록한 후 테이블 블록 변경한다. 이 때 변경된 블록은 Dirty Block 상태가 된다.
  11. 다른 트랜잭션에 의해 변경된 데이터 블록에 대한 CR 블록이 생성된다.
  12. 커밋을 시도!
  13. 트랜잭션에 SCN이 할당되고 커밋 정보는 리두 버퍼에 저장된다.
  14. 언두 세그먼트 헤더의 트랜잭션 테이블에 커밋이 이루어졌음을 저장한뒤 락 점유를 해체한다.
  15. 리두 버퍼의 내용을 리두 파일에 기록한다.
# 3. Delayed 블록 클린아웃
- 변경된 데이터 블록들 중 Fast commit에 의해 cleanout 되지 않은 블록들을 나중에 cleanout 처리하는 것이다.
- Delayed block cleanout이 발생하는 경우 순수한 Select 작업인 경우에도 cleanout 작업 자체에 대한 리두 데이터가 생성될 수 있다.
- 갱신한 블록 개수가 총 버퍼 캐시 블록 개수의 1/10 초과시 적용한다.
## 1) fast commit
- 커밋 시점에 모든 블록에 대해 cleanout을 수행하지 않는다는 것을 의미한다.
- 성능을 고려하여 변경된 데이터 블록들 중 버퍼 캐시에 올라와 있는 일부 블록들에 대해서만 cleanout을 수행한다.
- 커밋시점에 변경되는 정보의 량을 최소화한다.
- ITL 정보에서 Flag와 SCN 정보만 변경되고 lock byte 정보는 변경되지 않는다.
  - 트랜잭션에 의해 변경된 모든 로우에 저장되므로 변경해야 할 데이터의 양이 많기 때문이다!
- 변경된 일부 데이터 블록들의 헤더에 대해서만 변경 작업을 수행한다.
- 리두 데이터가 생성되지 않고, 커밋 마크만이 리두에 저장된다.
- 수백만 건의 데이터를 변경한 후에 커밋을 수행하는 경우에도 매우 빠른 속도로 커밋 처리가 되는 것은 이러한 기법 덕분이다!😙
- Commit 시점에는 Undo 세그먼트 헤더의 트랜잭션 테이블에만 Commit 정보를 기록하며
블록 클린아웃 과정에서 수행하는 Commit 정보 기록과 로우 Lock 해제는 나중에 수행한다.
## 2) Block Cleanout
- 트랜잭션에 의해 설정된 로우 Lock을 해제하고 블록 헤더(캐시 체인)에 커밋 정보를 기록하는 오퍼레이션이다.
- 블록에 설정된 로우 레벨 락을 해제하고(Cleanout) ITL 정보(SCN, Flag, Lock Byte 등)가 갱신된다.
## 3) Delayed 블록 클린아웃 과정        
1. 블록을 읽는 과정에서 Active 상태(커밋 정보가 ITL에 없는 상태) 블록은 읽기 전에 먼저 블록 클린아웃을 시도 한다.
2. ITL 슬롯에 기록된 트랜잭션 ID를 이용해 Undo 세그먼트 헤더의 트랜잭션 테이블 슬롯을 찾아가 트랜잭션 상태를 확인한다.
3. 커밋된 트랜잭션이라면 ITL 슬롯에 커밋 정보를 저장한 뒤 레코드에 기록된 Lock Byte 를 해제하여 블록 클린아웃 처리한다.
4. 블록 클린아웃을 위한 갱신내용도 Redo 에 로깅 하고 블록 SCN을 변경한다.
### Block Cleanout 수행시 기록 내역
1. 블록 헤더 ITL 슬롯에 커밋 Flag과 커밋 SCN을 기록한다.
2. Redo 로그에 Commit Mark를 기록한다.
## 4) Delayed 블록 클린아웃이 수행되는 시점
- 다음 번에 해당 블록을 스캔하는 프로세스에 의해 클린아웃 처리된다.
		1. ITL 슬롯에 커밋 정보 저장
        2. 레코드에 기록된 Lock Byte 해제
        3. Online Redo 에 Logging
# 4. 커밋 클린아웃
- 'Fast 블록 클린아웃' 이라고도 한다.
- 'Delayed 로깅 블록 클린아웃' 이라고도 한다.
- 블록 클린아웃은 Current 블록에 작업을 수행하는데 이는 RAC/OPS 환경에서는 Exclusive 모드 Current 블록을 요청한다. ( 성능에 부정적이라는 소리다! )
- 즉..블록을 읽을 때 마다 블록 클린아웃이 필요하다면 성능에 부담스럽다.😢
- 따라서 갱신한 블록 개수가 총 버퍼 캐시 블록 개수의 1/10 이하시 커밋 시점에 바로 블록 클린아웃을 수행한다.
## Current 블록 클린아웃임에도 '불완전한 형태의 클린아웃'을 수행한다.
- 해당 블록을 갱신하는 다음 트랜잭션에 의해 완전한 클린아웃 처리를 한다.
- 커밋 시점에는 ITL 슬롯에 커밋 정보만 저장하고, 로우 헤더에 기록된 Lock Byte는 해제 하지 않는다.
  - Delayed Block Cleanout과 다른점
    - Delayed Block Cleanout은 ITL 슬롯에 커밋 정보도 저장하지 않아서 이후 트랜잭션이 조회하러 올 때 커밋 여부와 커밋 SCN 확인을 위해 트랜잭션 테이블을 조회해야 하는 번거로움이 있다.(맞나? 틀리면 댓글 부탁드립니닷 ㅠ😱)
    - '불완전한 형태의 클린아웃'은 ITL 슬롯에 커밋 정보는 저장하기 때문에 이후 트랜잭션이 조회하러 올 때 커밋 여부와 커밋 SCN 확인을 위해 트랜잭션 테이블을 조회하지 않아도 된다.
- 커밋 시점에는 로깅을 하지 않고 뒤로 미룬다.
- 이후 블록 액세스시 커밋 여부와 커밋 SCN 확인을 위해 트랜잭션 테이블 조회가 불필요하다.
(위에 바로 써있쥬?🤓)
- 이후 Current 모드로 읽는 시점에(이 때는 ITL 슬롯이 필요하다!) 비로소 Lock Byte를 해제하고 완전한 클린아웃을 수행한 뒤 Redo 로깅을 수행한다.
# 5. ITL과 블록 클린아웃
### ITL 정보 관찰을 위한 블록 Dump
![](https://velog.velcdn.com/images/yooha9621/post/ac41eadb-9f60-46f1-8068-a59e07006489/image.png)

### 1) 1번 슬롯(0x01)은 Fast 클린아웃 상태
- 로우 헤더에 Lock Byte가 미해제(Lck=1)
- 커밋 SCN 존재하며 Fast 클린아웃 상태가 표시(fsc)되어있다.
- Flag=U
- Lock Byte 해제로 2번 슬롯 상태로 만든 후 ITL 슬롯을 재사용할 수 있는 형태로 만든다.
### 2) 2번 슬롯(0x02)은 블록 클린아웃이 된 상태
- 언제든 ITL 슬롯 재사용 가능한 상태이다.
- Lock Byte 해제 상태 (Lck=0)
- 정확한 커밋 SCN이 존재한다.
- Flag=C
### 3) 3번 슬롯(0x03)은 Delayed 블록 클린아웃 상태
- Lock Byte 해제 상태 (Lck=0)
- 언제든 ITL 슬롯 재사용 가능
- 커밋 Flag 가 C-U- 인것은 추정된 커밋 SCN을 의미한다.